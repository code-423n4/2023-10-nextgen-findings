The `NextGen` contest is about launching generative art projects on Ethereum. The scope of the contest includes the following smart contracts:
`NextGenCore.sol`, `MinterContract.sol`, `NextGenAdmins.sol`, `RandomizerNXT.sol`, `RandomizerVRF.sol`, `RandomizerRNG.sol`, `XRandoms.sol`, `AuctionDemo.sol`.

The first smart contract `NextGenCore.sol` is an ERC721 token (a standard for non-fungible tokens on the Ethereum blockchain). It is designed to manage a collection of unique digital assets, each represented by a unique token ID. The contract includes functionality for creating and managing collections of these tokens, including setting and updating metadata, minting new tokens, burning existing tokens, and managing royalties. It also includes functionality for managing administrative roles and permissions, and for interacting with other contracts, such as a randomizer contract and a minter contract. The contract includes several mappings to keep track of various data associated with the tokens and collections, such as the total supply, the circulation supply, the maximum number of purchases allowed, and the artist's signature.

The second file `MinterContract.sol` is for a smart contract named `NextGenMinterContract`. This contract is used for minting tokens in a collection, managing royalties, and handling the sale of tokens. It also includes functionality for burning tokens to mint new ones, airdropping tokens, and setting up auctions. The contract imports several other contracts and interfaces, including `Ownable.sol`, which provides basic authorization control functions, and several other contracts specific to the `NextGen` project. The contract uses several mappings to keep track of various data such as the total amount collected during minting, the timestamp of the last mint, and the burn or swap address for external collections. It defines several structs to store data related to collection phases, royalties splits, and artist addresses and includes several modifiers to restrict access to certain functions based on the role of the caller (e.g., admin, artist). The contract includes a constructor that sets the addresses of the `NextGenCore` `DelegationManagementContract`, and `NextGenAdmins` contracts. Also, it includes several functions for managing the minting process, including setting collection costs, setting collection phases, airdropping tokens, and minting tokens, functions for managing royalties, including setting primary and secondary splits, proposing and accepting addresses and percentages, and paying the artist, functions for managing auctions, including minting and auctioning tokens. The contract includes also functions for managing delegation, including updating the delegation collection and initializing burn to mint for `NextGen` collections and functions for withdrawing any balance from the smart contract and updating the core and admin contracts.

The `NextGenAdmins.sol` file defines a contract named `NextGenAdmins` that manages administrative permissions for a system. It uses the `Ownable` contract, which provides basic authorization control functions, simplifying the implementation of "user permissions". The contract has three types of admins: global admins, function-specific admins, and collection-specific admins. These are stored in mappings `adminPermissions`, `functionAdmin`, and `collectionAdmin` respectively. The `constructor` function sets the contract deployer as a global admin. The `AdminRequired` modifier ensures that only global admins or the contract owner can call certain functions. The `registerAdmin` function allows the contract owner to add or remove global admins.The `registerFunctionAdmin` and `registerBatchFunctionAdmin` functions allow an admin to add or remove function-specific admins. The `registerCollectionAdmin` function allows an admin to add or remove collection-specific admins. The `retrieveGlobalAdmin`, `retrieveFunctionAdmin`, and `retrieveCollectionAdmin` functions allow anyone to check if an address is a global admin, function-specific admin, or collection-specific admin respectively. The `isAdminContract` function returns true, indicating that this contract is an admin contract.

The `RandomizerNXT.sol` file is about contract, named `NextGenRandomizerNXT` and involves random number generation and administration of certain functions. It imports four other contracts: `IXRandoms`, `INextGenAdmins`, `Ownable`, and `INextGenCore`. The contract has a constructor that initializes three other contracts: `IXRandoms`, `INextGenAdmins`, and `INextGenCore`. The addresses of these contracts are passed as arguments to the constructor. The contract has a modifier `FunctionAdminRequired` that checks if the caller is an admin for a specific function or a global admin. This is a security measure to ensure that only authorized addresses can call certain functions. The contract has three functions to update the addresses of the `IXRandoms`, `INextGenAdmins`, and `INextGenCore` contracts. These functions can only be called by an admin, as enforced by the `FunctionAdminRequired` modifier. The `calculateTokenHash` function generates a hash using the `_mintIndex`, the hash of the last block, a random number, and a random word. It then sets this hash in the `INextGenCore` contract. This function can only be called by the `gencore` address. The `isRandomizerContract` function is a simple function that returns `true`, indicating that this contract is a randomizer contract.

The `RandomizerVRF.sol` file is a solidity contract, named `NextGenRandomizerVRF`. It is a random number generator that uses Chainlink's Verifiable Random Function (VRF). It's designed to work with a token system. The key functions of this contract are: `requestRandomWords(uint256 tokenid)` - requests random words from the Chainlink VRF. It maps the token ID to the request ID and vice versa. `fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords)` -  this function is called when the Chainlink VRF fulfills the request for random words. It sets the token hash in the gencoreContract and emits an event. `calculateTokenHash(uint256 _collectionID, uint256 _mintIndex, uint256 _saltfun_o)` - calculates the token hash and requests random words. `updatecallbackGasLimitAndkeyHash(uint32 _callbackGasLimit, bytes32 _keyHash)` - updates the callback gas limit and key hash, `updateAdditionalData(uint64 _s_subscriptionId, uint32 _numWords, uint16 _requestConfirmations)` - updates the subscription ID, number of words, and request confirmations, `updateAdminContract(address _newadminsContract)` - updates the admin contract and `updateCoreContract(address _gencore)` - updates the core contract. The contract also includes a modifier `FunctionAdminRequired(bytes4 _selector)` to ensure that only authorized admins can call certain functions.

The `RandomizerRNG.sol` file presents the contract `NextGenRandomizerRNG` that is used to generate random numbers for a token. It uses an external random number generator service (`ArrngConsumer`), and it's ownable, meaning it has an owner who has special privileges. The contract has several mappings to keep track of requests for random numbers, tokens, and collections. It also has a constructor that sets up the contract with the necessary addresses for the core and admin contracts. The `FunctionAdminRequired` modifier is used to restrict access to certain functions to only admins. The `requestRandomWords` function is used to request random numbers from the external service. The `fulfillRandomWords` function is used to receive the random numbers from the external service and set the token hash in the core contract. The `calculateTokenHash` function is used to initiate the process of generating a random hash for a token. The `updateAdminContract`, `updateCoreContract`, and `updateRNGCost` functions are used to update the admin contract, core contract, and cost of requesting random numbers respectively. The `emergencyWithdraw` function is used to withdraw all the funds from the contract in case of an emergency. The `receive` function is used to allow the contract to receive funds. The `isRandomizerContract` function is used to check if the contract is a randomizer contract.

The `XRandoms.sol` file defines the solidity contract, named `randomPool` and contains four functions. The `getWord(uint256 id)` function is a private function that returns a word from a predefined list of 100 words based on the input `id`. If `id` is 0, it returns the first word; otherwise, it returns the word at the `id - 1` index. The `randomNumber()` public function generates a pseudo-random number between 0 and 999 using the `keccak256` hash of the previous block's randao, the hash of the block before the current one, and the current block's timestamp. This method of generating randomness is not secure and can be manipulated by miners. The `randomWord()` public function generates a pseudo-random number between 0 and 99 (same security issue as `randomNumber()`) and uses it to return a random word from the list. The `returnIndex(uint256 id)` public function returns a word from the list based on the input `id`, using the `getWord()` function.

The last contract `AuctionDemo.sol` is for an auction. It allows users to participate in an auction, place bids, cancel bids, and claim the auctioned item. The contract also includes functions to return the highest bid and the highest bidder for a given auction. The contract imports several other contracts/interfaces: `IMinterContract`, `IERC721`, `Ownable` and `INextGenAdmins`. These are used for minting tokens, handling `ERC721` tokens, managing contract ownership, and managing admins respectively. The contract defines several events for claiming an auction, refunding, and cancelling a bid. The contract has a modifier `WinnerOrAdminRequired` that restricts certain functions to be called only by the auction winner or an admin and defines a struct `auctionInfoStru` to hold information about each bid, and a mapping `auctionInfoData` to hold all bids for each auction. The contract has a function `participateToAuction` that allows users to place a bid on an auction and has functions `returnHighestBid` and `returnHighestBidder` to return the highest bid and the highest bidder for a given auction. The contract has a function `claimAuction` that allows the auction winner or an admin to claim the auctioned item. The contract has functions `cancelBid` and `cancelAllBids` that allow a bidder to cancel their bid or all their bids. Also, the contract has a function `returnBids` that returns all bids for a given auction.

I worked on this contest 5 days and found several problems. The most important for me is that there is a centralization risk in terms of admin privileges. The admins have a big role in the project. But the problem I see is that anyone who deploys the `NextGenAdmins.sol` contract can become an admin. It is recommended to add a list of trusted addresses that can be admins and by deploying the `NextGenAdmins.sol` contract to check if the msg.sender is whitelisted. The other issues I found are related reentrancy, front-running attack, weak randomness and some lows and gas optimization. The contest was interesting and I hope my findings are valuable.

### Time spent:
40 hours